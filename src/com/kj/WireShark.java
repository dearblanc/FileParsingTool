package com.kj;

import com.kj.enc.Key;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class WireShark {
    private static final Object mFileLock = new Object();

    WireShark() {}

    public static String adaptAuthAlgorithm(String src) {
        String algorithm = null;
        if (src.equalsIgnoreCase("hmac-sha1") || src.equalsIgnoreCase("hmac(sha1)")) {
            algorithm = "HMAC-SHA-1-96 [RFC2404]";
        } else if (src.equalsIgnoreCase("hmac-sha256") || src.equalsIgnoreCase("hmac(sha256)")) {
            algorithm = "HMAC-SHA-256-128 [RFC4868]";
        } else if (src.equalsIgnoreCase("hmac-sha384") || src.equalsIgnoreCase("hmac(sha384)")) {
            algorithm = "HMAC-SHA-384-192 [RFC4868]";
        } else if (src.equalsIgnoreCase("hmac-sha512") || src.equalsIgnoreCase("hmac(sha512)")) {
            algorithm = "HMAC-SHA-512-256 [RFC4868]";
        } else if (src.equalsIgnoreCase("hmac-md5") || src.equalsIgnoreCase("hmac(md5)")) {
            algorithm = "HMAC-MD5-96 [RFC2403]";
        } else if (src.equalsIgnoreCase("hmac-rmd160") || src.equalsIgnoreCase("hmac(rmd160)")) {
            algorithm = "MAC-RIPEMD-160-96 [RFC2857]";
        } else if (src.contains("null")) {
            algorithm = "NULL";
        }
        return algorithm;
    }

    public static String adaptEncryptionAlgorithm(String src) {
        String algorithm = null;

        if (src.equalsIgnoreCase("aes-cbc") || src.equalsIgnoreCase("cbc(aes)")) {
            algorithm = "AES-CBC [RFC3602]";
        } else if (src.equalsIgnoreCase("des-cbc") || src.equalsIgnoreCase("cbc(des)")) {
            algorithm = "DES-CBC [RFC2405]";
        } else if (src.equalsIgnoreCase("3des-cbc") || src.equalsIgnoreCase("cbc(3des)")) {
            algorithm = "TripleDES-CBC [RFC2451]";
        } else if (src.equalsIgnoreCase("cast5-cbc") || src.equalsIgnoreCase("cbc(cast5)")) {
            algorithm = "CAST5-CBC [RFC2144]";
        } else if (src.equalsIgnoreCase("blowfish-cbc") || src.equalsIgnoreCase("cbc(blowfish)")) {
            algorithm = "BLOWFISH-CBC [RFC2451]";
        } else if (src.equalsIgnoreCase("twofish-cbc") || src.equalsIgnoreCase("cbc(twofish)")) {
            algorithm = "TWOFISH-CBC";
        } else if (src.equalsIgnoreCase("aes-ctr") || src.equalsIgnoreCase("ctr(aes)")) {
            algorithm = "AES-CTR [RFC3686]";
        } else if (src.equalsIgnoreCase("aes-gcm") || src.equalsIgnoreCase("gcm(aes)")) {
            algorithm = "AES-GCM [RFC4106]";
        } else if (src.contains("null")) {
            algorithm = "NULL";
        }

        return algorithm;
    }

    static void saveKeys(List<KJFile> fileList) {
        List<Key> keys = new ArrayList<>();
        fileList.forEach(f -> keys.addAll(f.getKeys()));
        List<Key> distinctKeys = keys.stream().distinct().collect(Collectors.toList());

        synchronized (mFileLock) {
            final RandomAccessFile file;
            try {
                file = new RandomAccessFile("C:\\Users\\user\\AppData\\Roaming\\Wireshark\\esp_sa", "rw");
            } catch (FileNotFoundException e) {
                e.printStackTrace();
                return;
            }
            String strLine = "";

            try {
                while ((strLine = file.readLine()) != null) {
                    final String line = strLine;
                    distinctKeys.removeIf(k -> line.contains(k.getSpi()));
                }

                byte[] carriageReturn = System.getProperty("line.separator").getBytes();
                long fileLength = file.length();
                if (fileLength == 0) {
                    file.write("# This file is automatically generated, DO NOT MODIFY.".getBytes());
                    file.write(carriageReturn);
                }

                file.seek(file.length() - 1);
                String lastLine = file.readLine();

                if (lastLine != null && !lastLine.trim().isEmpty()) {
                    file.write(carriageReturn);
                }
                distinctKeys.forEach(k -> {
                    try {
                        file.write(k.printKey().getBytes());
                        file.write(carriageReturn);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                });
            } catch (IllegalArgumentException | SecurityException | IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    file.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
